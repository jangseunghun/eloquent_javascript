<html><head><link rel="stylesheet" type="text/css" href="css/book.css"/><link rel="stylesheet" type="text/css" href="css/highlight.css"/><link rel="stylesheet" type="text/css" href="css/console.css"/><link rel="stylesheet" type="text/css" href="css/codemirror.css"/><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>함수형 프로그래밍 -- Eloquent JavaScript</title></head><body><script type="text/javascript" src="js/before.js"> </script><div class="content"><script type="text/javascript">var chapterTag = 'fp';</script><div class="navigation"><a href="chapter5.html">&lt;&lt; 이전 장</a> | <a href="contents.html">목차</a> | <a href="index.html">소개</a> | <a href="chapter7.html">다음 장 &gt;&gt;</a></div><h1><span class="number">6장: </span>함수형 프로그래밍</h1><div class="block"><p><a class="paragraph" href="#pdba7201" name="pdba7201"> ¶ </a>프로그램은 규모가 커질수록 더 복잡해지고 이해하기 어려워진다. 우리는 대부분 스스로를 똑똑하다고 생각하지만 여전히 사람일 뿐이고 조금만 혼돈이 와도 쉽게 당황하게 된다. 그렇게 우리는 쉽게 무너지게 되는 것이다. 여러분이 제대로 이해하고 있지 못하는 것을 작업하는 것은 영화에 항상 등장하는 시간폭탄의 색상 선을 제거하는 일과 같다. 여러분이 운이 좋다면 영화에 나오는 주인공들처럼 시간폭탄을 멈출 수 있는 선을 끊어 세상을 구할 수도 있지만 반대로 선을 잘못 선택해 모든 것을 망쳐 버릴 수도 있는 것이다.</p><p><a class="paragraph" href="#p48332aa5" name="p48332aa5"> ¶ </a>물론, 하나의 프로그램을 망친다고 해서 큰 폭팔 사고가 나는 것은 아니다. 하지만 한 사람이 서툰 실력으로 프로그램을 손보게 돼 오류들로 엉망이 된 상태가 된다면 다시 제대로 돌아가는 프로그램으로 원상복귀시키는 데는 엄청난 노력이 필요하다. 심지어 가끔은 차라리 다시 새로 시작하는 것이 더 효율적일 수도 있다.</p><p><a class="paragraph" href="#p22f00be3" name="p22f00be3"> ¶ </a><a name="key1"></a>그렇기 때문에 프로그래머는 자신의 프로그램을 최대한 복잡하지 않게 하기 위한 방법들을 지속적으로 연구해야 한다. 그 중 한가지 중요한 방법은 코딩을 더 추상적으로 쓰는 것이다. 프로그램을 코딩할 때 덜 중요한 세부항목들 때문에 옆길로 새기 쉽다. 다시 말해 여러분이 작은 문제들을 발견하게 되고 그것을 처리한 다음에 다시 또 작은 문제에 부딪치고 처리하고 이런 식으로 진행할 때다. 이는 마치 할머니의 긴 이야기를 듣는 것처럼 코드를 는 것과 같다.</p><blockquote>그래, 콩 스프를 만들기 위해서 너는 먼저 잘라진 콩이 필요할꺼야. 마른 콩들이어야 하지. 그리고 최소한 하루밤 정도는 물에 담가놔둬야돼. 안그러면 몇시간동안 익혀야 하게 될테니까. 예전에 내 둔한 아들이 콩 스프를 만들 때가 생각나네. 그 애가 콩을 물에 담가두지 않았단 걸 믿겠니? 우리들은 거의 이빨이 부셔지는 줄 알았어. 하여튼 콩을 적시게 되면 한 사람당 한 컵의 콩을 관리해야돼. 그리고 금방 물을 흡수해 커지게 되니까 콩들을 잘 살펴봐야돼. 안그럼 콩을 담아두었던 그릇에서 밖으로 쏟아져 넘치게 될꺼야. 그러니 물도 충분히 넣어야하고 한 컵당. 적신 콩들이 마르게 되면 다시 한컵의 콩당 네컵의 물을 넣어서 요리를 하면 돼. 두시간 정도 끓이게 되면 간신히 거의 익혀질랑 말랑 했을 때인데 네모 모양의 양파와 셀러리를 잘라서 넣으면 돼. 당근 한 두개랑 햄도 같이 잘라 넣어도 돼고. 그리고 몇분 동안 더 끓이고 나서 먹으면 돼. </blockquote><p><a class="paragraph" href="#p14dcdc06" name="p14dcdc06"> ¶ </a>또 이번에는 다른 방식으로 레시피를 설명할 수도 있다: </p><blockquote>한 사람 당 : 한 컵의 잘린 콩들, 반개의 잘린 양파, 반개의 당근, 셀러리 그리고 햄.<br/><br/>콩들을 하룻밤동안 물에 불린다. 두시간 정도로 콩을 네컵 정도의 물을 넣어 끓인 다음에 채소들과 햄을 넣어 십분 정도 더 끓이면 된다.</blockquote><p><a class="paragraph" href="#p11843d6d" name="p11843d6d"> ¶ </a>이 방식의 레시피가 훨씬 짧지만 여러분은 어떻게 콩을 물에 불리는지 모른다면 당연히 물을 너무 조금 넣어 망치게 될 것이다. 하지만 콩을 어떻게 불리는 지는 찾아보면 된다. 바로 이게 요령인 것이다. 만약 여러분이 상대방이 어느 정도의 지식을 갖춘 상태임을 가정한다면 여러분은 더 큰 개념들을 다루는 언어적 표현을 통해 의사 소통을 할 수 있을 것이고 모든 것들을 더 짧고 명확한 방식으로 전달하고 표현할 수 있을 것이다. 이것이 바로 추상화의 의미이다.</p><p><a class="paragraph" href="#p74512153" name="p74512153"> ¶ </a>어떻게 이렇게 동떨어진 레시피 이야기가 프로그래밍과 연관이 있을까? 여기서 레시피는 프로그램을 의미한다. 그리고 요리하는 사람이 가져야 할 기본 지식이란 프로그래머가 이용할 수 있는 함수들과 다른 구조체들을 의미한다. 여러분들이 이책의 서론에서 봤듯이 <code>while</code> 과 같은 제어문들은 반복문을 쉽게 만들 수 있게 한다. 또한 이 책 <a href="chapter4.html">4장</a>에서 우리들은 다른 함수들을 더 짧고 직관적이게 만들기 위해 몇몇 단순한 함수들을 썼다. 이러한 몇몇 도구들은 컴퓨터 언어 자체에서 제공해주는 것들과 프로그래머 스스로 정의한 것들이 있는데 프로그램 나머지 부분에 있는 중요하지 않은 세부사항들을 줄이고 더 쉽게 프로그램을 이용할 수 있도록 사용된다. </p></div><hr/><div class="block"><p><a class="paragraph" href="#p4bd24fc8" name="p4bd24fc8"> ¶ </a>이 챕터의 주제인 <a name="key2"></a>함수형 프로그래밍이란 함수들을 영리하게 조합해 코딩을 추상화시키는 것을 말한다. 기본 함수들을 목록으로 가지고 있고 또 더 나아가 그것들을 어떻게 사용해야 하는지 알고 있는 프로그래머는 단순히 갓 시작한 프로그래머보다 훨씬 더 강력한 힘을 가진다. 안타깝게도, 일반적인 자바 스크립트 환경에서는 정말로 적은 숫자의 함수들만 존재하기 때문에 우리들은 스스로 함수를 정의해야 하거나 혹은 더 선호되는 방식으로 다른 사람들이 만든 코딩을 이용할 수밖에 없다(이에 대해선 <a href="chapter9.html">9장</a>에서 더 자세히 설명한다).</p><p><a class="paragraph" href="#p493dfe2f" name="p493dfe2f"> ¶ </a>코딩의 추상화를 달성하는 데에는 여러가지 다른 일반적인 접근 방식들이 존재하는데 <a href="chapter8.html">8장</a>에서 배우게 될 객체 지향 프로그래밍이 가장 주목할 만하다. </p></div><hr/><div class="block"><p><a class="paragraph" href="#p41af5b12" name="p41af5b12"> ¶ </a>여러분이 함수형 프로그래밍에 익숙하지 않을 때 여러분을 귀찮게 하는 지저분하고 사소한 일의 한가지는 배열을 대상으로 하는 <code>for</code> 문을 반복적으로 사용하는 일 것이다: <code>for (var i = 0; i &lt; something.length; i++) ...</code>. ...이것을 추상화시킬 수 있을까?</p><p><a class="paragraph" href="#p233c1f28" name="p233c1f28"> ¶ </a>The 대부분의 함수들이 어떤 값를 가지고 그것들을 합치고 반환하는 반면에 반드시 실행해야 하는 코드를 갖는 반복문의 경우 문제가 된다. 한 배열을 반복하면서 모든 요소를 출력하는 함수를 쓰는 것은 간단하다:</p><pre class="code"><span class="keyword">function</span> <span class="variable">printArray</span>(<span class="variabledef">array</span>) {
  <span class="keyword">for</span> (<span class="keyword">var</span> <span class="variabledef">i</span> = <span class="atom">0</span>; <span class="localvariable">i</span> &lt; <span class="localvariable">array</span>.<span class="property">length</span>; <span class="localvariable">i</span>++)
    <span class="variable">print</span>(<span class="localvariable">array</span>[<span class="localvariable">i</span>]);
}</pre><p><a class="paragraph" href="#p59124288" name="p59124288"> ¶ </a>But what if we want to do something else than print? Since 'doing
something' can be represented as a function, and functions are also
values, we can pass our action as a function value:</p><pre class="code"><span class="keyword">function</span> <span class="variable">forEach</span>(<span class="variabledef">array</span>, <span class="variabledef">action</span>) {
  <span class="keyword">for</span> (<span class="keyword">var</span> <span class="variabledef">i</span> = <span class="atom">0</span>; <span class="localvariable">i</span> &lt; <span class="localvariable">array</span>.<span class="property">length</span>; <span class="localvariable">i</span>++)
    <span class="localvariable">action</span>(<span class="localvariable">array</span>[<span class="localvariable">i</span>]);
}

<span class="variable">forEach</span>([<span class="string">&quot;Wampeter&quot;</span>, <span class="string">&quot;Foma&quot;</span>, <span class="string">&quot;Granfalloon&quot;</span>], <span class="variable">print</span>);</pre><p><a class="paragraph" href="#p6a42ebd3" name="p6a42ebd3"> ¶ </a>And by making use of an anonymous function, something just like a
<code>for</code> loop can be written with less useless details:</p><pre class="code"><span class="keyword">function</span> <span class="variable">sum</span>(<span class="variabledef">numbers</span>) {
  <span class="keyword">var</span> <span class="variabledef">total</span> = <span class="atom">0</span>;
  <span class="variable">forEach</span>(<span class="localvariable">numbers</span>, <span class="keyword">function</span> (<span class="variabledef">number</span>) {
    <span class="localvariable">total</span> += <span class="localvariable">number</span>;
  });
  <span class="keyword">return</span> <span class="localvariable">total</span>;
}
<span class="variable">show</span>(<span class="variable">sum</span>([<span class="atom">1</span>, <span class="atom">10</span>, <span class="atom">100</span>]));</pre><p><a class="paragraph" href="#p60f93e69" name="p60f93e69"> ¶ </a>Note that the variable <code>total</code> is visible inside the anonymous
function because of the lexical scoping rules. Also note that this
version is hardly shorter than the <code>for</code> loop and requires a rather
clunky <code>});</code> at its end ― the brace closes the body of the anonymous
function, the parenthesis closes the function call to <a name="key3"></a><code>forEach</code>, and
the semicolon is needed because this call is a statement.</p><p><a class="paragraph" href="#p5dd5ffb7" name="p5dd5ffb7"> ¶ </a>You do get a variable bound to the current element in the array,
<code>number</code>, so there is no need to use <code>numbers[i]</code> anymore, and when
this array is created by evaluating some expression, there is no need
to store it in a variable, because it can be passed to <code>forEach</code>
directly.</p><p><a class="paragraph" href="#p43687e97" name="p43687e97"> ¶ </a>The cat-code in <a href="chapter4.html">chapter 4</a> contains a piece like this:</p><pre class="preformatted">var paragraphs = mailArchive[mail].split(&quot;\n&quot;);
for (var i = 0; i &lt; paragraphs.length; i++)
  handleParagraph(paragraphs[i]);</pre><p><a class="paragraph" href="#p33b4c9e0" name="p33b4c9e0"> ¶ </a>This can now be written as...</p><pre class="preformatted">forEach(mailArchive[mail].split(&quot;\n&quot;), handleParagraph);</pre><p><a class="paragraph" href="#p28c1c73c" name="p28c1c73c"> ¶ </a>On the whole, using more abstract (or 'higher level') constructs
results in more information and less noise: The code in <code>sum</code> reads
'<em>for each number in numbers add that number to the total</em>', instead
of... '<em>there is this variable that starts at zero, and it counts
upward to the length of the array called numbers, and for every value
of this variable we look up the corresponding element in the array and
add this to the total</em>'.</p></div><hr/><div class="block"><p><a class="paragraph" href="#p381c8ab4" name="p381c8ab4"> ¶ </a>What <code>forEach</code> does is take an algorithm, in this case 'going over an
array', and abstract it. The 'gaps' in the algorithm, in this case,
what to do for each of these elements, are filled by functions which
are passed to the algorithm function.</p><p><a class="paragraph" href="#p55eb429c" name="p55eb429c"> ¶ </a>Functions that operate on other functions are called <a name="key4"></a>higher-order
functions. By operating on functions, they can talk about actions on
a whole new level. The <code>makeAddFunction</code> function from <a href="chapter3.html">chapter 3</a> is
also a higher-order function. Instead of taking a function value as an
argument, it produces a new function.</p><p><a class="paragraph" href="#p2a85a26a" name="p2a85a26a"> ¶ </a>Higher-order functions can be used to generalise many algorithms that
regular functions can not easily describe. When you have a repertoire
of these functions at your disposal, it can help you think about your
code in a clearer way: Instead of a messy set of variables and loops,
you can decompose algorithms into a combination of a few fundamental
algorithms, which are invoked by name, and do not have to be typed out
again and again.</p><p><a class="paragraph" href="#p7333b993" name="p7333b993"> ¶ </a>Being able to write <em>what</em> we want to do instead of <em>how</em> we do it
means we are working at a higher level of abstraction. In practice,
this means shorter, clearer, and more pleasant code.</p></div><hr/><div class="block"><p><a class="paragraph" href="#p66d4381c" name="p66d4381c"> ¶ </a>Another useful type of higher-order function <em>modifies</em> the function
value it is given:</p><pre class="code"><span class="keyword">function</span> <span class="variable">negate</span>(<span class="variabledef">func</span>) {
  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="variabledef">x</span>) {
    <span class="keyword">return</span> !<span class="localvariable">func</span>(<span class="localvariable">x</span>);
  };
}
<span class="keyword">var</span> <span class="variable">isNotNaN</span> = <span class="variable">negate</span>(<span class="variable">isNaN</span>);
<span class="variable">show</span>(<span class="variable">isNotNaN</span>(<span class="atom">NaN</span>));</pre><p><a class="paragraph" href="#p4be645ae" name="p4be645ae"> ¶ </a>The function returned by <code>negate</code> feeds the argument it is given to
the original function <code>func</code>, and then negates the result. But what if
the function you want to negate takes more than one argument? You can
get access to any arguments passed to a function with the <code>arguments</code>
array, but how do you call a function when you do not know how many
arguments you have?</p><p><a class="paragraph" href="#p7e592821" name="p7e592821"> ¶ </a>Functions have a method called <a name="key5"></a><code>apply</code>, which is used for situations
like this. It takes two arguments. The role of the first argument will
be discussed in <a href="chapter8.html">chapter 8</a>, for now we just use <code>null</code> there. The second
argument is an array containing the arguments that the function must
be applied to.</p><pre class="code"><span class="variable">show</span>(<span class="variable">Math</span>.<span class="property">min</span>.<span class="property">apply</span>(<span class="atom">null</span>, [<span class="atom">5</span>, <span class="atom">6</span>]));

<span class="keyword">function</span> <span class="variable">negate</span>(<span class="variabledef">func</span>) {
  <span class="keyword">return</span> <span class="keyword">function</span>() {
    <span class="keyword">return</span> !<span class="localvariable">func</span>.<span class="property">apply</span>(<span class="atom">null</span>, <span class="localvariable">arguments</span>);
  };
}</pre><p><a class="paragraph" href="#p71e39590" name="p71e39590"> ¶ </a>Unfortunately, on the Internet Explorer browser a lot of built-in
functions, such as <code>alert</code>, are not <em>really</em> functions... or
something. They report their type as <code>&quot;object&quot;</code> when given to the
<code>typeof</code> operator, and they do not have an <code>apply</code> method. Your own
functions do not suffer from this, they are always real functions.</p></div><hr/><div class="block"><p><a class="paragraph" href="#p65e9846c" name="p65e9846c"> ¶ </a>Let us look at a few more basic algorithms related to arrays. The
<code>sum</code> function is really a variant of an algorithm which is usually
called <a name="key6"></a><code>reduce</code> or <code>fold</code>:</p><pre class="code"><span class="keyword">function</span> <span class="variable">reduce</span>(<span class="variabledef">combine</span>, <span class="variabledef">base</span>, <span class="variabledef">array</span>) {
  <span class="variable">forEach</span>(<span class="localvariable">array</span>, <span class="keyword">function</span> (<span class="variabledef">element</span>) {
    <span class="localvariable">base</span> = <span class="localvariable">combine</span>(<span class="localvariable">base</span>, <span class="localvariable">element</span>);
  });
  <span class="keyword">return</span> <span class="localvariable">base</span>;
}

<span class="keyword">function</span> <span class="variable">add</span>(<span class="variabledef">a</span>, <span class="variabledef">b</span>) {
  <span class="keyword">return</span> <span class="localvariable">a</span> + <span class="localvariable">b</span>;
}

<span class="keyword">function</span> <span class="variable">sum</span>(<span class="variabledef">numbers</span>) {
  <span class="keyword">return</span> <span class="variable">reduce</span>(<span class="variable">add</span>, <span class="atom">0</span>, <span class="localvariable">numbers</span>);
}</pre><p><a class="paragraph" href="#p5d539372" name="p5d539372"> ¶ </a><code>reduce</code> combines an array into a single value by repeatedly using a
function that combines an element of the array with a base value. This
is exactly what <code>sum</code> did, so it can be made shorter by using
<code>reduce</code>... except that addition is an operator and not a function in
JavaScript, so we first had to put it into a function.</p><p><a class="paragraph" href="#p20272a57" name="p20272a57"> ¶ </a>The reason <code>reduce</code> takes the function as its first argument instead
of its last, as in <code>forEach</code>, is partly that this is tradition ―
other languages do it like that ― and partly that this allows us to
use a particular trick, which will be discussed at the end of this
chapter. It does mean that, when calling <code>reduce</code>, writing the
reducing function as an anonymous function looks a bit weirder,
because now the other arguments follow after the function, and the
resemblance to a normal <code>for</code> block is lost entirely.</p></div><hr/><div class="block"><a name="exercise1"></a><div class="exercisenum">Ex. 6.1</div><div class="exercise"><p><a class="paragraph" href="#p4f13f0ae" name="p4f13f0ae"> ¶ </a>Write a function <code>countZeroes</code>, which takes an array of numbers as its
argument and returns the amount of zeroes that occur in it. Use
<code>reduce</code>.</p><p><a class="paragraph" href="#p771065b3" name="p771065b3"> ¶ </a>Then, write the higher-order function <code>count</code>, which takes an array
and a test function as arguments, and returns the amount of elements
in the array for which the test function returned <code>true</code>. Re-implement
<code>countZeroes</code> using this function.</p></div><div class="solution"><pre class="code"><span class="keyword">function</span> <span class="variable">countZeroes</span>(<span class="variabledef">array</span>) {
  <span class="keyword">function</span> <span class="variabledef">counter</span>(<span class="variabledef">total</span>, <span class="variabledef">element</span>) {
    <span class="keyword">return</span> <span class="localvariable">total</span> + (<span class="localvariable">element</span> === <span class="atom">0</span> ? <span class="atom">1</span> : <span class="atom">0</span>);
  }
  <span class="keyword">return</span> <span class="variable">reduce</span>(<span class="localvariable">counter</span>, <span class="atom">0</span>, <span class="localvariable">array</span>);
}</pre><p><a class="paragraph" href="#p51f254f4" name="p51f254f4"> ¶ </a><a name="key7"></a>The weird part, with the question mark and the colon, uses a
new operator. In <a href="chapter2.html">chapter 2</a> we have seen unary and binary operators.
This one is ternary ― it acts on three values. Its effect resembles
that of <code>if</code>/<code>else</code>, except that, where <code>if</code> conditionally executes
statements, this one conditionally chooses expressions. The first
part, before the question mark, is the condition. If this condition is
<code>true</code>, the expression after the question mark is chosen, <code>1</code> in this
case. If it is <code>false</code>, the part after the colon, <code>0</code> in this case, is
chosen.</p><p><a class="paragraph" href="#p6dafdb5f" name="p6dafdb5f"> ¶ </a>Use of this operator can make some pieces of code much shorter. When
the expressions inside it get very big, or you have to make more
decisions inside the conditional parts, just using plain <code>if</code> and
<code>else</code> is usually more readable.</p><p><a class="paragraph" href="#p17f801c5" name="p17f801c5"> ¶ </a>Here is the solution that uses a <code>count</code> function, with a function
that produces equality-testers included to make the final
<code>countZeroes</code> function even shorter:</p><pre class="code"><span class="keyword">function</span> <span class="variable">count</span>(<span class="variabledef">test</span>, <span class="variabledef">array</span>) {
  <span class="keyword">return</span> <span class="variable">reduce</span>(<span class="keyword">function</span>(<span class="variabledef">total</span>, <span class="variabledef">element</span>) {
    <span class="keyword">return</span> <span class="localvariable">total</span> + (<span class="localvariable">test</span>(<span class="localvariable">element</span>) ? <span class="atom">1</span> : <span class="atom">0</span>);
  }, <span class="atom">0</span>, <span class="localvariable">array</span>);
}

<span class="keyword">function</span> <span class="variable">equals</span>(<span class="variabledef">x</span>) {
  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="variabledef">element</span>) {<span class="keyword">return</span> <span class="localvariable">x</span> === <span class="localvariable">element</span>;};
}

<span class="keyword">function</span> <span class="variable">countZeroes</span>(<span class="variabledef">array</span>) {
  <span class="keyword">return</span> <span class="variable">count</span>(<span class="variable">equals</span>(<span class="atom">0</span>), <span class="localvariable">array</span>);
}</pre></div></div><hr/><div class="block"><p><a class="paragraph" href="#p31aabc64" name="p31aabc64"> ¶ </a>One other generally useful 'fundamental algorithm' related to arrays
is called <a name="key8"></a><code>map</code>. It goes over an array, applying a function to every
element, just like <code>forEach</code>. But instead of discarding the values
returned by function, it builds up a new array from these values.</p><pre class="code"><span class="keyword">function</span> <span class="variable">map</span>(<span class="variabledef">func</span>, <span class="variabledef">array</span>) {
  <span class="keyword">var</span> <span class="variabledef">result</span> = [];
  <span class="variable">forEach</span>(<span class="localvariable">array</span>, <span class="keyword">function</span> (<span class="variabledef">element</span>) {
    <span class="localvariable">result</span>.<span class="property">push</span>(<span class="localvariable">func</span>(<span class="localvariable">element</span>));
  });
  <span class="keyword">return</span> <span class="localvariable">result</span>;
}

<span class="variable">show</span>(<span class="variable">map</span>(<span class="variable">Math</span>.<span class="property">round</span>, [<span class="atom">0.01</span>, <span class="atom">2</span>, <span class="atom">9.89</span>, <span class="variable">Math</span>.<span class="property">PI</span>]));</pre><p><a class="paragraph" href="#p5fd5e2eb" name="p5fd5e2eb"> ¶ </a>Note that the first argument is called <code>func</code>, not <code>function</code>, this
is because <code>function</code> is a keyword and thus not a valid variable name.</p></div><hr/><div class="block"><p><a class="paragraph" href="#p90fad98" name="p90fad98"> ¶ </a>There once was, living in the deep mountain forests of Transylvania, a
recluse. Most of the time, he just wandered around his mountain,
talking to trees and laughing with birds. But now and then, when the
pouring rain trapped him in his little hut, and the howling wind made
him feel unbearably small, the recluse felt an urge to write
something, wanted to pour some thoughts out onto paper, where they
could maybe grow bigger than he himself was.</p><p><a class="paragraph" href="#p2791bb49" name="p2791bb49"> ¶ </a>After failing miserably at poetry, fiction, and philosophy, the
recluse finally decided to write a technical book. In his youth, he
had done some computer programming, and he figured that if he could
just write a good book about that, fame and recognition would surely
follow.</p><p><a class="paragraph" href="#p4d93f533" name="p4d93f533"> ¶ </a>So he wrote. At first he used fragments of tree bark, but that turned
out not to be very practical. He went down to the nearest village and
bought himself a laptop computer. After a few chapters, he realised he
wanted to put the book in HTML format, in order to put it on his
web-page...</p></div><hr/><div class="block"><p><a class="paragraph" href="#p9122c78" name="p9122c78"> ¶ </a>Are you familiar with HTML? It is the method used to add mark-up to
pages on the web, and we will be using it a few times in this book, so
it would be nice if you know how it works, at least generally. If you
are a good student, you could go search the web for a good
introduction to HTML now, and come back here when you have read it.
Most of you probably are lousy students, so I will just give a short
explanation and hope it is enough.</p><p><a class="paragraph" href="#p5794a279" name="p5794a279"> ¶ </a><a name="key9"></a>HTML stands for 'HyperText Mark-up Language'. An HTML document is
all text. Because it must be able to express the structure of this
text, information about which text is a heading, which text is purple,
and so on, a few characters have a special meaning, somewhat like
backslashes in JavaScript strings. The 'less than' and 'greater than'
characters are used to create '<a name="key10"></a>tags'. A tag gives extra information
about the text in the document. It can stand on its own, for example
to mark the place where a picture should appear in the page, or it can
contain text and other tags, for example when it marks the start and
end of a paragraph.</p><p><a class="paragraph" href="#p6aaf57b4" name="p6aaf57b4"> ¶ </a>Some tags are compulsory, a whole HTML document must always be
contained in between <code>html</code> tags. Here is an example of an HTML
document:</p><pre class="preformatted">&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;A quote&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;A quote&lt;/h1&gt;
    &lt;blockquote&gt;
      &lt;p&gt;The connection between the language in which we
      think/program and the problems and solutions we can imagine
      is very close.  For this reason restricting language
      features with the intent of eliminating programmer errors is
      at best dangerous.&lt;/p&gt;
      &lt;p&gt;-- Bjarne Stroustrup&lt;/p&gt;
    &lt;/blockquote&gt;
    &lt;p&gt;Mr. Stroustrup is the inventor of the C++ programming
    language, but quite an insightful person nevertheless.&lt;/p&gt;
    &lt;p&gt;Also, here is a picture of an ostrich:&lt;/p&gt;
    &lt;img src=&quot;img/ostrich.png&quot;/&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre><p><a class="paragraph" href="#p4e929324" name="p4e929324"> ¶ </a>Elements that contain text or other tags are first opened with
<code>&lt;tagname&gt;</code>, and afterwards finished with <code>&lt;/tagname&gt;</code>. The <code>html</code>
element always contains two children: <code>head</code> and <code>body</code>. The first
contains information <em>about</em> the document, the second contains the
actual document.</p><p><a class="paragraph" href="#p3bcd5a53" name="p3bcd5a53"> ¶ </a>Most tag names are cryptic abbreviations. <code>h1</code> stands for 'heading 1',
the biggest kind of heading. There are also <code>h2</code> to <code>h6</code> for
successively smaller headings. <code>p</code> means 'paragraph', and <code>img</code> stands
for 'image'. The <code>img</code> element does not contain any text or other
tags, but it does have some extra information,
<code>src=&quot;img/ostrich.png&quot;</code>, which is called an '<a name="key11"></a>attribute'. In this
case, it contains information about the image file that should be
shown here.</p><p><a class="paragraph" href="#p6ad6b347" name="p6ad6b347"> ¶ </a>Because <code>&lt;</code> and <code>&gt;</code> have a special meaning in HTML documents, they can
not be written directly in the text of the document. If you want to
say '<code>5 &lt; 10</code>' in an HTML document, you have to write '<code>5 &amp;lt; 10</code>',
where '<code>lt</code>' stands for 'less than'. '<code>&amp;gt;</code>' is used for '<code>&gt;</code>', and
because these codes also give the ampersand character a special
meaning, a plain '<code>&amp;</code>' is written as '<code>&amp;amp;</code>'.</p><p><a class="paragraph" href="#p33441e2c" name="p33441e2c"> ¶ </a>Now, those are only the bare basics of HTML, but they should be enough
to make it through this chapter, and later chapters that deal with
HTML documents, without getting entirely confused.</p></div><hr/><div class="block"><p><a class="paragraph" href="#p1ccd441e" name="p1ccd441e"> ¶ </a>The JavaScript console has a function <code>viewHTML</code> that can be used to
look at HTML documents. I stored the example document above in the
variable <code>stroustrupQuote</code>, so you can view it by executing the
following code:</p><pre class="code"><span class="variable">viewHTML</span>(<span class="variable">stroustrupQuote</span>);</pre><p><a class="paragraph" href="#p7ba1b955" name="p7ba1b955"> ¶ </a>If you have some kind of pop-up blocker installed or integrated in
your browser, it will probably interfere with <code>viewHTML</code>, which tries
to show the HTML document in a new window or tab. Try to configure the
blocker to allow pop-ups from this site.</p></div><hr/><div class="block"><p><a class="paragraph" href="#p2243ec78" name="p2243ec78"> ¶ </a>So, picking up the story again, the recluse wanted to have his book in
HTML format. At first he just wrote all the tags directly into his
manuscript, but typing all those less-than and greater-than signs made
his fingers hurt, and he constantly forgot to write <code>&amp;amp;</code> when he
needed an <code>&amp;</code>. This gave him a headache. Next, he tried to write the
book in Microsoft Word, and then save it as HTML. But the HTML that
came out of that was fifteen times bigger and more complicated than it
had to be. And besides, Microsoft Word gave him a headache.</p><p><a class="paragraph" href="#p27166a36" name="p27166a36"> ¶ </a>The solution that he eventually came up with was this: He would write
the book as plain text, following some simple rules about the way
paragraphs were separated and the way headings looked. Then, he would
write a program to convert this text into precisely the HTML that he
wanted.</p><p><a class="paragraph" href="#p13270a6e" name="p13270a6e"> ¶ </a>The rules are this:</p><ol><li>Paragraphs are separated by blank lines.</li><li>A paragraph that starts with a '%' symbol is a header. The more '%' symbols, the smaller the header.</li><li>Inside paragraphs, pieces of text can be emphasised by putting them between asterisks.</li><li>Footnotes are written between braces.</li></ol></div><hr/><div class="block"><p><a class="paragraph" href="#p1bcc111" name="p1bcc111"> ¶ </a>After he had struggled painfully with his book for six months, the
recluse had still only finished a few paragraphs. At this point, his
hut was struck by lightning, killing him, and forever putting his
writing ambitions to rest. From the charred remains of his laptop, I
could recover the following file:</p><pre class="preformatted">% The Book of Programming

%% The Two Aspects

Below the surface of the machine, the program moves. Without effort,
it expands and contracts. In great harmony, electrons scatter and
regroup. The forms on the monitor are but ripples on the water. The
essence stays invisibly below.

When the creators built the machine, they put in the processor and the
memory. From these arise the two aspects of the program.

The aspect of the processor is the active substance. It is called
Control. The aspect of the memory is the passive substance. It is
called Data.

Data is made of merely bits, yet it takes complex forms. Control
consists only of simple instructions, yet it performs difficult
tasks. From the small and trivial, the large and complex arise.

The program source is Data. Control arises from it. The Control
proceeds to create new Data. The one is born from the other, the
other is useless without the one. This is the harmonious cycle of
Data and Control.

Of themselves, Data and Control are without structure. The programmers
of old moulded their programs out of this raw substance. Over time,
the amorphous Data has crystallised into data types, and the chaotic
Control was restricted into control structures and functions.

%% Short Sayings

When a student asked Fu-Tzu about the nature of the cycle of Data and
Control, Fu-Tzu replied 'Think of a compiler, compiling itself.'

A student asked 'The programmers of old used only simple machines and
no programming languages, yet they made beautiful programs. Why do we
use complicated machines and programming languages?'. Fu-Tzu replied
'The builders of old used only sticks and clay, yet they made
beautiful huts.'

A hermit spent ten years writing a program. 'My program can compute
the motion of the stars on a 286-computer running MS DOS', he proudly
announced. 'Nobody owns a 286-computer or uses MS DOS anymore.',
Fu-Tzu responded.

Fu-Tzu had written a small program that was full of global state and
dubious shortcuts. Reading it, a student asked 'You warned us against
these techniques, yet I find them in your program. How can this be?'
Fu-Tzu said 'There is no need to fetch a water hose when the house is
not on fire.'{This is not to be read as an encouragement of sloppy
programming, but rather as a warning against neurotic adherence to
rules of thumb.}

%% Wisdom

A student was complaining about digital numbers. 'When I take the root
of two and then square it again, the result is already inaccurate!'.
Overhearing him, Fu-Tzu laughed. 'Here is a sheet of paper. Write down
the precise value of the square root of two for me.'

Fu-Tzu said 'When you cut against the grain of the wood, much strength
is needed. When you program against the grain of a problem, much code
is needed.'

Tzu-li and Tzu-ssu were boasting about the size of their latest
programs. 'Two-hundred thousand lines', said Tzu-li, 'not counting
comments!'. 'Psah', said Tzu-ssu, 'mine is almost a *million* lines
already.' Fu-Tzu said 'My best program has five hundred lines.'
Hearing this, Tzu-li and Tzu-ssu were enlightened.

A student had been sitting motionless behind his computer for hours,
frowning darkly. He was trying to write a beautiful solution to a
difficult problem, but could not find the right approach. Fu-Tzu hit
him on the back of his head and shouted '*Type something!*' The student
started writing an ugly solution. After he had finished, he suddenly
understood the beautiful solution.

%% Progression

A beginning programmer writes his programs like an ant builds her
hill, one piece at a time, without thought for the bigger structure.
His programs will be like loose sand. They may stand for a while, but
growing too big they fall apart{Referring to the danger of internal
inconsistency and duplicated structure in unorganised code.}.

Realising this problem, the programmer will start to spend a lot of
time thinking about structure. His programs will be rigidly
structured, like rock sculptures. They are solid, but when they must
change, violence must be done to them{Referring to the fact that
structure tends to put restrictions on the evolution of a program.}.

The master programmer knows when to apply structure and when to leave
things in their simple form. His programs are like clay, solid yet
malleable.

%% Language

When a programming language is created, it is given syntax and
semantics. The syntax describes the form of the program, the semantics
describe the function. When the syntax is beautiful and the semantics
are clear, the program will be like a stately tree. When the syntax is
clumsy and the semantics confusing, the program will be like a bramble
bush.

Tzu-ssu was asked to write a program in the language called Java,
which takes a very primitive approach to functions. Every morning, as
he sat down in front of his computer, he started complaining. All day
he cursed, blaming the language for all that went wrong. Fu-Tzu
listened for a while, and then reproached him, saying 'Every language
has its own way. Follow its form, do not try to program as if you
were using another language.'</pre></div><hr/><div class="block"><p><a class="paragraph" href="#p6210d6e" name="p6210d6e"> ¶ </a>To honour the memory of our good recluse, I would like to finish his
HTML-generating program for him. A good approach to this problem goes
like this:</p><ol><li>Split the file into paragraphs by cutting it at every empty line.</li><li>Remove the '%' characters from header paragraphs and mark them as headers.</li><li>Process the text of the paragraphs themselves, splitting them into normal parts, emphasised parts, and footnotes.</li><li>Move all the footnotes to the bottom of the document, leaving numbers<a class="footref" href="#footnote1">1</a> in their place.</li><li>Wrap each piece into the correct HTML tags.</li><li>Combine everything into a single HTML document.</li></ol><p><a class="paragraph" href="#p43aa90ef" name="p43aa90ef"> ¶ </a>This approach does not allow footnotes inside emphasised text, or vice
versa. This is kind of arbitrary, but helps keep the example code
simple. If, at the end of the chapter, you feel like an extra
challenge, you can try to revise the program to support 'nested'
mark-up.</p><p><a class="paragraph" href="#p5a9170c0" name="p5a9170c0"> ¶ </a>The whole manuscript, as a string value, is available on this page
by calling <code>recluseFile</code> function.</p></div><hr/><div class="block"><p><a class="paragraph" href="#p609697c5" name="p609697c5"> ¶ </a>Step 1 of the algorithm is trivial. A blank line is what you get when
you have two newlines in a row, and if you remember the <code>split</code> method
that strings have, which we saw in <a href="chapter4.html">chapter 4</a>, you will realise that this
will do the trick:</p><pre class="code"><span class="keyword">var</span> <span class="variable">paragraphs</span> = <span class="variable">recluseFile</span>().<span class="property">split</span>(<span class="string">&quot;\n\n&quot;</span>);
<span class="variable">print</span>(<span class="string">&quot;Found &quot;</span>, <span class="variable">paragraphs</span>.<span class="property">length</span>, <span class="string">&quot; paragraphs.&quot;</span>);</pre></div><hr/><div class="block"><a name="exercise2"></a><div class="exercisenum">Ex. 6.2</div><div class="exercise"><p><a class="paragraph" href="#p314f5c0e" name="p314f5c0e"> ¶ </a>Write a function <code>processParagraph</code> that, when given a paragraph
string as its argument, checks whether this paragraph is a header. If
it is, it strips off the '%' characters and counts their number. Then,
it returns an object with two properties, <code>content</code>, which contains
the text inside the paragraph, and <code>type</code>, which contains the tag that
this paragraph must be wrapped in, <code>&quot;p&quot;</code> for regular paragraphs,
<code>&quot;h1&quot;</code> for headers with one '%', and <code>&quot;hX&quot;</code> for headers with <code>X</code> '%'
characters.</p><p><a class="paragraph" href="#p600dfe59" name="p600dfe59"> ¶ </a>Remember that strings have a <code>charAt</code> method that can be used to look
at a specific character inside them.</p></div><div class="solution"><pre class="code"><span class="keyword">function</span> <span class="variable">processParagraph</span>(<span class="variabledef">paragraph</span>) {
  <span class="keyword">var</span> <span class="variabledef">header</span> = <span class="atom">0</span>;
  <span class="keyword">while</span> (<span class="localvariable">paragraph</span>.<span class="property">charAt</span>(<span class="atom">0</span>) == <span class="string">&quot;%&quot;</span>) {
    <span class="localvariable">paragraph</span> = <span class="localvariable">paragraph</span>.<span class="property">slice</span>(<span class="atom">1</span>);
    <span class="localvariable">header</span>++;
  }

  <span class="keyword">return</span> {<span class="property">type</span>: (<span class="localvariable">header</span> == <span class="atom">0</span> ? <span class="string">&quot;p&quot;</span> : <span class="string">&quot;h&quot;</span> + <span class="localvariable">header</span>),
          <span class="property">content</span>: <span class="localvariable">paragraph</span>};
}

<span class="variable">show</span>(<span class="variable">processParagraph</span>(<span class="variable">paragraphs</span>[<span class="atom">0</span>]));</pre></div></div><hr/><div class="block"><p><a class="paragraph" href="#p48e0f55c" name="p48e0f55c"> ¶ </a>This is where we can try out the <code>map</code> function we saw earlier.</p><pre class="code"><span class="keyword">var</span> <span class="variable">paragraphs</span> = <span class="variable">map</span>(<span class="variable">processParagraph</span>,
                     <span class="variable">recluseFile</span>().<span class="property">split</span>(<span class="string">&quot;\n\n&quot;</span>));</pre><p><a class="paragraph" href="#p2c85f79a" name="p2c85f79a"> ¶ </a>And <em>bang</em>, we have an array of nicely categorised paragraph objects.
We are getting ahead of ourselves though, we forgot step 3 of the
algorithm:</p><blockquote>Process the text of the paragraphs themselves, splitting them into
normal parts, emphasised parts, and footnotes.</blockquote><p><a class="paragraph" href="#p76208de3" name="p76208de3"> ¶ </a>Which can be decomposed into:</p><ol><li>If the paragraph starts with an asterisk, take off the emphasised part and store it.</li><li>If the paragraph starts with an opening brace, take off the footnote and store it.</li><li>Otherwise, take off the part until the first emphasised part or footnote, or until the end of the string, and store it as normal text.</li><li>If there is anything left in the paragraph, start at 1 again.</li></ol></div><hr/><div class="block"><a name="exercise3"></a><div class="exercisenum">Ex. 6.3</div><div class="exercise"><p><a class="paragraph" href="#p17fd4c81" name="p17fd4c81"> ¶ </a>Build a function <code>splitParagraph</code> which, given a paragraph string,
returns an array of paragraph fragments. Think of a good way to
represent the fragments.</p><p><a class="paragraph" href="#p49668e4b" name="p49668e4b"> ¶ </a>The method <code>indexOf</code>, which searches for a character or sub-string in
a string and returns its position, or <code>-1</code> if not found, will probably
be useful in some way here.</p><p><a class="paragraph" href="#p15ac600b" name="p15ac600b"> ¶ </a>This is a tricky algorithm, and there are many not-quite-correct or
way-too-long ways to describe it. If you run into problems, just think
about it for a minute. Try to write inner functions that perform the
smaller actions that make up the algorithm.</p></div><div class="solution"><p><a class="paragraph" href="#p6f95d6da" name="p6f95d6da"> ¶ </a>Here is one possible solution:</p><pre class="code"><span class="keyword">function</span> <span class="variable">splitParagraph</span>(<span class="variabledef">text</span>) {
  <span class="keyword">function</span> <span class="variabledef">indexOrEnd</span>(<span class="variabledef">character</span>) {
    <span class="keyword">var</span> <span class="variabledef">index</span> = <span class="localvariable">text</span>.<span class="property">indexOf</span>(<span class="localvariable">character</span>);
    <span class="keyword">return</span> <span class="localvariable">index</span> == -<span class="atom">1</span> ? <span class="localvariable">text</span>.<span class="property">length</span> : <span class="localvariable">index</span>;
  }

  <span class="keyword">function</span> <span class="variabledef">takeNormal</span>() {
    <span class="keyword">var</span> <span class="variabledef">end</span> = <span class="variable">reduce</span>(<span class="variable">Math</span>.<span class="property">min</span>, <span class="localvariable">text</span>.<span class="property">length</span>,
                     <span class="variable">map</span>(<span class="localvariable">indexOrEnd</span>, [<span class="string">&quot;*&quot;</span>, <span class="string">&quot;{&quot;</span>]));
    <span class="keyword">var</span> <span class="variabledef">part</span> = <span class="localvariable">text</span>.<span class="property">slice</span>(<span class="atom">0</span>, <span class="localvariable">end</span>);
    <span class="localvariable">text</span> = <span class="localvariable">text</span>.<span class="property">slice</span>(<span class="localvariable">end</span>);
    <span class="keyword">return</span> <span class="localvariable">part</span>;
  }

  <span class="keyword">function</span> <span class="variabledef">takeUpTo</span>(<span class="variabledef">character</span>) {
    <span class="keyword">var</span> <span class="variabledef">end</span> = <span class="localvariable">text</span>.<span class="property">indexOf</span>(<span class="localvariable">character</span>, <span class="atom">1</span>);
    <span class="keyword">if</span> (<span class="localvariable">end</span> == -<span class="atom">1</span>)
      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="variable">Error</span>(<span class="string">&quot;Missing closing '&quot;</span> + <span class="localvariable">character</span> + <span class="string">&quot;'&quot;</span>);
    <span class="keyword">var</span> <span class="variabledef">part</span> = <span class="localvariable">text</span>.<span class="property">slice</span>(<span class="atom">1</span>, <span class="localvariable">end</span>);
    <span class="localvariable">text</span> = <span class="localvariable">text</span>.<span class="property">slice</span>(<span class="localvariable">end</span> + <span class="atom">1</span>);
    <span class="keyword">return</span> <span class="localvariable">part</span>;
  }

  <span class="keyword">var</span> <span class="variabledef">fragments</span> = [];

  <span class="keyword">while</span> (<span class="localvariable">text</span> != <span class="string">&quot;&quot;</span>) {
    <span class="keyword">if</span> (<span class="localvariable">text</span>.<span class="property">charAt</span>(<span class="atom">0</span>) == <span class="string">&quot;*&quot;</span>)
      <span class="localvariable">fragments</span>.<span class="property">push</span>({<span class="property">type</span>: <span class="string">&quot;emphasised&quot;</span>,
                      <span class="property">content</span>: <span class="localvariable">takeUpTo</span>(<span class="string">&quot;*&quot;</span>)});
    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="localvariable">text</span>.<span class="property">charAt</span>(<span class="atom">0</span>) == <span class="string">&quot;{&quot;</span>)
      <span class="localvariable">fragments</span>.<span class="property">push</span>({<span class="property">type</span>: <span class="string">&quot;footnote&quot;</span>,
                      <span class="property">content</span>: <span class="localvariable">takeUpTo</span>(<span class="string">&quot;}&quot;</span>)});
    <span class="keyword">else</span>
      <span class="localvariable">fragments</span>.<span class="property">push</span>({<span class="property">type</span>: <span class="string">&quot;normal&quot;</span>,
                      <span class="property">content</span>: <span class="localvariable">takeNormal</span>()});
  }
  <span class="keyword">return</span> <span class="localvariable">fragments</span>;
}</pre><p><a class="paragraph" href="#p6198f3ee" name="p6198f3ee"> ¶ </a>Note the over-eager use of <code>map</code> and <code>reduce</code> in the <code>takeNormal</code>
function. This is a chapter about functional programming, so program
functionally we will! Can you see how this works? The <code>map</code> produces
an array of positions where the given characters were found, or the
end of the string if they were not found, and the <code>reduce</code> takes the
minimum of them, which is the next point in the string that we have to
look at.</p><p><a class="paragraph" href="#p10e82198" name="p10e82198"> ¶ </a>If you'd write that out without mapping and reducing you'd get
something like this:</p><pre class="preformatted">var nextAsterisk = text.indexOf(&quot;*&quot;);
var nextBrace = text.indexOf(&quot;{&quot;);
var end = text.length;
if (nextAsterisk != -1)
  end = nextAsterisk;
if (nextBrace != -1 &amp;&amp; nextBrace &lt; end)
  end = nextBrace;</pre><p><a class="paragraph" href="#p2dea3e6b" name="p2dea3e6b"> ¶ </a>Which is even more hideous. Most of the time, when a decision has to
be made based on a series of things, even if there are only two of
them, writing it as array operations is nicer than handling every
value in a separate <code>if</code> statement. (Fortunately, <a href="chapter10.html">chapter 10</a> describes
an easier way to ask for the first occurrence of 'this or that
character' in a string.)</p><p><a class="paragraph" href="#pa5f95de" name="pa5f95de"> ¶ </a>If you wrote a <code>splitParagraph</code> that stored fragments in a different
way than the solution above, you might want to adjust it, because the
functions in the rest of the chapter assume that fragments are objects
with <code>type</code> and <code>content</code> properties.</p></div></div><hr/><div class="block"><p><a class="paragraph" href="#p25a1695" name="p25a1695"> ¶ </a>We can now wire <code>processParagraph</code> to also split the text inside the
paragraphs, my version can be modified like this:</p><pre class="code"><span class="keyword">function</span> <span class="variable">processParagraph</span>(<span class="variabledef">paragraph</span>) {
  <span class="keyword">var</span> <span class="variabledef">header</span> = <span class="atom">0</span>;
  <span class="keyword">while</span> (<span class="localvariable">paragraph</span>.<span class="property">charAt</span>(<span class="atom">0</span>) == <span class="string">&quot;%&quot;</span>) {
    <span class="localvariable">paragraph</span> = <span class="localvariable">paragraph</span>.<span class="property">slice</span>(<span class="atom">1</span>);
    <span class="localvariable">header</span>++;
  }

  <span class="keyword">return</span> {<span class="property">type</span>: (<span class="localvariable">header</span> == <span class="atom">0</span> ? <span class="string">&quot;p&quot;</span> : <span class="string">&quot;h&quot;</span> + <span class="localvariable">header</span>),
          <span class="property">content</span>: <span class="variable">splitParagraph</span>(<span class="localvariable">paragraph</span>)};
}</pre><p><a class="paragraph" href="#p312fdb46" name="p312fdb46"> ¶ </a>Mapping that over the array of paragraphs gives us an array of
paragraph objects, which in turn contain arrays of fragment objects.
The next thing to do is to take out the footnotes, and put references
to them in their place. Something like this:</p><pre class="code"><span class="keyword">function</span> <span class="variable">extractFootnotes</span>(<span class="variabledef">paragraphs</span>) {
  <span class="keyword">var</span> <span class="variabledef">footnotes</span> = [];
  <span class="keyword">var</span> <span class="variabledef">currentNote</span> = <span class="atom">0</span>;

  <span class="keyword">function</span> <span class="variabledef">replaceFootnote</span>(<span class="variabledef">fragment</span>) {
    <span class="keyword">if</span> (<span class="localvariable">fragment</span>.<span class="property">type</span> == <span class="string">&quot;footnote&quot;</span>) {
      <span class="localvariable">currentNote</span>++;
      <span class="localvariable">footnotes</span>.<span class="property">push</span>(<span class="localvariable">fragment</span>);
      <span class="localvariable">fragment</span>.<span class="property">number</span> = <span class="localvariable">currentNote</span>;
      <span class="keyword">return</span> {<span class="property">type</span>: <span class="string">&quot;reference&quot;</span>, <span class="property">number</span>: <span class="localvariable">currentNote</span>};
    }
    <span class="keyword">else</span> {
      <span class="keyword">return</span> <span class="localvariable">fragment</span>;
    }
  }

  <span class="variable">forEach</span>(<span class="localvariable">paragraphs</span>, <span class="keyword">function</span>(<span class="variabledef">paragraph</span>) {
    <span class="localvariable">paragraph</span>.<span class="property">content</span> = <span class="variable">map</span>(<span class="localvariable">replaceFootnote</span>,
                            <span class="localvariable">paragraph</span>.<span class="property">content</span>);
  });

  <span class="keyword">return</span> <span class="localvariable">footnotes</span>;
}     </pre><p><a class="paragraph" href="#p469001e7" name="p469001e7"> ¶ </a>The <code>replaceFootnote</code> function is called on every fragment. When it
gets a fragment that should stay where it is, it just returns it, but
when it gets a footnote, it stores this footnote in the <code>footnotes</code>
array, and returns a reference to it instead. In the process, every
footnote and reference is also numbered.</p></div><hr/><div class="block"><p><a class="paragraph" href="#p68cc7e1d" name="p68cc7e1d"> ¶ </a>That gives us enough tools to extract the information we need from the
file. All that is left now is generating the correct HTML.</p><p><a class="paragraph" href="#p295ef3e4" name="p295ef3e4"> ¶ </a>A lot of people think that concatenating strings is a great way to
produce HTML. When they need a link to, for example, a site where you
can play the game of Go, they will do:</p><pre class="code"><span class="keyword">var</span> <span class="variable">url</span> = <span class="string">&quot;http://www.gokgs.com/&quot;</span>;
<span class="keyword">var</span> <span class="variable">text</span> = <span class="string">&quot;Play Go!&quot;</span>;
<span class="keyword">var</span> <span class="variable">linkText</span> = <span class="string">&quot;&lt;a href=\&quot;&quot;</span> + <span class="variable">url</span> + <span class="string">&quot;\&quot;&gt;&quot;</span> + <span class="variable">text</span> + <span class="string">&quot;&lt;/a&gt;&quot;</span>;
<span class="variable">print</span>(<span class="variable">linkText</span>);</pre><p><a class="paragraph" href="#p516f6ec8" name="p516f6ec8"> ¶ </a>(Where <code>a</code> is the tag used to create links in HTML documents.) ... Not
only is this clumsy, but when the string <code>text</code> happens to include an
angular bracket or an ampersand, it is also wrong. Weird things will
happen on your website, and you will look embarrassingly amateurish.
We wouldn't want that to happen. A few simple HTML-generating
functions are easy to write. So let us write them.</p></div><hr/><div class="block"><p><a class="paragraph" href="#p5864c59c" name="p5864c59c"> ¶ </a>The secret to successful HTML generation is to treat your HTML
document as a data structure instead of a flat piece of text.
JavaScript's objects provide a very easy way to model this:</p><pre class="code"><span class="keyword">var</span> <span class="variable">linkObject</span> = {<span class="property">name</span>: <span class="string">&quot;a&quot;</span>,
                  <span class="property">attributes</span>: {<span class="property">href</span>: <span class="string">&quot;http://www.gokgs.com/&quot;</span>},
                  <span class="property">content</span>: [<span class="string">&quot;Play Go!&quot;</span>]};</pre><p><a class="paragraph" href="#p743ec741" name="p743ec741"> ¶ </a>Each HTML element contains a <code>name</code> property, giving the name of the
tag it represents. When it has attributes, it also contains an
<code>attributes</code> property, which contains an object in which the
attributes are stored. When it has content, there is a <code>content</code>
property, containing an array of other elements contained in this
element. Strings play the role of pieces of text in our HTML document,
so the array <code>[&quot;Play Go!&quot;]</code> means that this link has only one element
inside it, which is a simple piece of text.</p><p><a class="paragraph" href="#p33ca40c3" name="p33ca40c3"> ¶ </a>Typing in these objects directly is clumsy, but we don't have to do
that. We provide a shortcut function to do this for us:</p><pre class="code"><span class="keyword">function</span> <span class="variable">tag</span>(<span class="variabledef">name</span>, <span class="variabledef">content</span>, <span class="variabledef">attributes</span>) {
  <span class="keyword">return</span> {<span class="property">name</span>: <span class="localvariable">name</span>, <span class="property">attributes</span>: <span class="localvariable">attributes</span>, <span class="property">content</span>: <span class="localvariable">content</span>};
}</pre><p><a class="paragraph" href="#p42d6e46b" name="p42d6e46b"> ¶ </a>Note that, since we allow the <code>attributes</code> and <code>content</code> of an element
to be undefined if they are not applicable, the second and third
argument to this function can be left off when they are not needed.</p><p><a class="paragraph" href="#p483f2724" name="p483f2724"> ¶ </a><code>tag</code> is still rather primitive, so we write shortcuts for common
types of elements, such as links, or the outer structure of a simple
document:</p><pre class="code"><span class="keyword">function</span> <span class="variable">link</span>(<span class="variabledef">target</span>, <span class="variabledef">text</span>) {
  <span class="keyword">return</span> <span class="variable">tag</span>(<span class="string">&quot;a&quot;</span>, [<span class="localvariable">text</span>], {<span class="property">href</span>: <span class="localvariable">target</span>});
}

<span class="keyword">function</span> <span class="variable">htmlDoc</span>(<span class="variabledef">title</span>, <span class="variabledef">bodyContent</span>) {
  <span class="keyword">return</span> <span class="variable">tag</span>(<span class="string">&quot;html&quot;</span>, [<span class="variable">tag</span>(<span class="string">&quot;head&quot;</span>, [<span class="variable">tag</span>(<span class="string">&quot;title&quot;</span>, [<span class="localvariable">title</span>])]),
                      <span class="variable">tag</span>(<span class="string">&quot;body&quot;</span>, <span class="localvariable">bodyContent</span>)]);
}</pre></div><hr/><div class="block"><a name="exercise4"></a><div class="exercisenum">Ex. 6.4</div><div class="exercise"><p><a class="paragraph" href="#p2bce3455" name="p2bce3455"> ¶ </a>Looking back at the example HTML document if necessary, write an
<code>image</code> function which, when given the location of an image file, will
create an <code>img</code> HTML element.</p></div><div class="solution"><pre class="code"><span class="keyword">function</span> <span class="variable">image</span>(<span class="variabledef">src</span>) {
  <span class="keyword">return</span> <span class="variable">tag</span>(<span class="string">&quot;img&quot;</span>, [], {<span class="property">src</span>: <span class="localvariable">src</span>});
}</pre></div></div><hr/><div class="block"><p><a class="paragraph" href="#pbc708e2" name="pbc708e2"> ¶ </a>When we have created a document, it will have to be reduced to a
string. But building this string from the data structures we have been
producing is very straightforward. The important thing is to remember
to transform the special characters in the text of our document...</p><pre class="code"><span class="keyword">function</span> <span class="variable">escapeHTML</span>(<span class="variabledef">text</span>) {
  <span class="keyword">var</span> <span class="variabledef">replacements</span> = [[<span class="string">/&amp;/g</span>, <span class="string">&quot;&amp;amp;&quot;</span>], [<span class="string">/&quot;/g</span>, <span class="string">&quot;&amp;quot;&quot;</span>],
                      [<span class="string">/&lt;/g</span>, <span class="string">&quot;&amp;lt;&quot;</span>], [<span class="string">/&gt;/g</span>, <span class="string">&quot;&amp;gt;&quot;</span>]];
  <span class="variable">forEach</span>(<span class="localvariable">replacements</span>, <span class="keyword">function</span>(<span class="variabledef">replace</span>) {
    <span class="localvariable">text</span> = <span class="localvariable">text</span>.<span class="property">replace</span>(<span class="localvariable">replace</span>[<span class="atom">0</span>], <span class="localvariable">replace</span>[<span class="atom">1</span>]);
  });
  <span class="keyword">return</span> <span class="localvariable">text</span>;
}</pre><p><a class="paragraph" href="#p4d92929f" name="p4d92929f"> ¶ </a>The <code>replace</code> method of strings creates a new string in which all
occurrences of the pattern in the first argument are replaced by the
second argument, so <code>&quot;Borobudur&quot;.replace(/r/g, &quot;k&quot;)</code> gives
<code>&quot;Bokobuduk&quot;</code>. Don't worry about the pattern syntax here ― we'll get
to that in <a href="chapter10.html">chapter 10</a>. The <code>escapeHTML</code> function puts the different
replacements that have to be made into an array, so that it can loop
over them and apply them to the argument one by one.</p><p><a class="paragraph" href="#p7011ea9f" name="p7011ea9f"> ¶ </a>Double quotes are also replaced, because we will also be using this
function for the text inside the attributes of HTML tags. Those will
be surrounded by double quotes, and thus must not have any double
quotes inside of them.</p><p><a class="paragraph" href="#p1f08d452" name="p1f08d452"> ¶ </a>Calling replace four times means the computer has to go over the whole
string four times to check and replace its content. This is not very
efficient. If we cared enough, we could write a more complex version
of this function, something that resembles the <code>splitParagraph</code>
function we saw earlier, to go over it only once. For now, we are too
lazy for this. Again, <a href="chapter10.html">chapter 10</a> shows a much better way to do this.</p></div><hr/><div class="block"><p><a class="paragraph" href="#p4a0c1d82" name="p4a0c1d82"> ¶ </a>To turn an HTML element object into a string, we can use a recursive
function like this:</p><pre class="code"><span class="keyword">function</span> <span class="variable">renderHTML</span>(<span class="variabledef">element</span>) {
  <span class="keyword">var</span> <span class="variabledef">pieces</span> = [];

  <span class="keyword">function</span> <span class="variabledef">renderAttributes</span>(<span class="variabledef">attributes</span>) {
    <span class="keyword">var</span> <span class="variabledef">result</span> = [];
    <span class="keyword">if</span> (<span class="localvariable">attributes</span>) {
      <span class="keyword">for</span> (<span class="keyword">var</span> <span class="variabledef">name</span> <span class="keyword">in</span> <span class="localvariable">attributes</span>) 
        <span class="localvariable">result</span>.<span class="property">push</span>(<span class="string">&quot; &quot;</span> + <span class="localvariable">name</span> + <span class="string">&quot;=\&quot;&quot;</span> +
                    <span class="variable">escapeHTML</span>(<span class="localvariable">attributes</span>[<span class="localvariable">name</span>]) + <span class="string">&quot;\&quot;&quot;</span>);
    }
    <span class="keyword">return</span> <span class="localvariable">result</span>.<span class="property">join</span>(<span class="string">&quot;&quot;</span>);
  }

  <span class="keyword">function</span> <span class="variabledef">render</span>(<span class="variabledef">element</span>) {
    <span class="comment">// Text node</span>
    <span class="keyword">if</span> (typeof <span class="localvariable">element</span> == <span class="string">&quot;string&quot;</span>) {
      <span class="localvariable">pieces</span>.<span class="property">push</span>(<span class="variable">escapeHTML</span>(<span class="localvariable">element</span>));
    }
    <span class="comment">// Empty tag</span>
    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="localvariable">element</span>.<span class="property">content</span> || <span class="localvariable">element</span>.<span class="property">content</span>.<span class="property">length</span> == <span class="atom">0</span>) {
      <span class="localvariable">pieces</span>.<span class="property">push</span>(<span class="string">&quot;&lt;&quot;</span> + <span class="localvariable">element</span>.<span class="property">name</span> +
                  <span class="localvariable">renderAttributes</span>(<span class="localvariable">element</span>.<span class="property">attributes</span>) + <span class="string">&quot;/&gt;&quot;</span>);
    }
    <span class="comment">// Tag with content</span>
    <span class="keyword">else</span> {
      <span class="localvariable">pieces</span>.<span class="property">push</span>(<span class="string">&quot;&lt;&quot;</span> + <span class="localvariable">element</span>.<span class="property">name</span> +
                  <span class="localvariable">renderAttributes</span>(<span class="localvariable">element</span>.<span class="property">attributes</span>) + <span class="string">&quot;&gt;&quot;</span>);
      <span class="variable">forEach</span>(<span class="localvariable">element</span>.<span class="property">content</span>, <span class="localvariable">render</span>);
      <span class="localvariable">pieces</span>.<span class="property">push</span>(<span class="string">&quot;&lt;/&quot;</span> + <span class="localvariable">element</span>.<span class="property">name</span> + <span class="string">&quot;&gt;&quot;</span>);
    }
  }

  <span class="localvariable">render</span>(<span class="localvariable">element</span>);
  <span class="keyword">return</span> <span class="localvariable">pieces</span>.<span class="property">join</span>(<span class="string">&quot;&quot;</span>);
}</pre><p><a class="paragraph" href="#p471d1a8c" name="p471d1a8c"> ¶ </a>Note the <code>in</code> loop that extracts the properties from a JavaScript
object in order to make HTML tag attributes out of them. Also note
that in two places, arrays are being used to accumulate strings, which
are then joined into a single result string. Why didn't I just start
with an empty string and then add the content to it with the <code>+=</code>
operator?</p><p><a class="paragraph" href="#p485d39b0" name="p485d39b0"> ¶ </a>It turns out that creating new strings, especially big strings, is
quite a lot of work. Remember that JavaScript string values never
change. If you concatenate something to them, a new string is created,
the old ones stay intact. If we build up a big string by concatenating
lots of little strings, new strings have to be created at every step,
only to be thrown away when the next piece is concatenated to them.
If, on the other hand, we store all the little strings in an array and
then join them, only <em>one</em> big string has to be created.</p></div><hr/><div class="block"><p><a class="paragraph" href="#p1055159c" name="p1055159c"> ¶ </a>So, let us try out this HTML generating system...</p><pre class="code"><span class="variable">print</span>(<span class="variable">renderHTML</span>(<span class="variable">link</span>(<span class="string">&quot;http://www.nedroid.com&quot;</span>, <span class="string">&quot;Drawings!&quot;</span>)));</pre><p><a class="paragraph" href="#p709880b0" name="p709880b0"> ¶ </a>That seems to work.</p><pre class="code"><span class="keyword">var</span> <span class="variable">body</span> = [<span class="variable">tag</span>(<span class="string">&quot;h1&quot;</span>, [<span class="string">&quot;The Test&quot;</span>]),
            <span class="variable">tag</span>(<span class="string">&quot;p&quot;</span>, [<span class="string">&quot;Here is a paragraph, and an image...&quot;</span>]),
            <span class="variable">image</span>(<span class="string">&quot;img/sheep.png&quot;</span>)];
<span class="keyword">var</span> <span class="variable">doc</span> = <span class="variable">htmlDoc</span>(<span class="string">&quot;The Test&quot;</span>, <span class="variable">body</span>);
<span class="variable">viewHTML</span>(<span class="variable">renderHTML</span>(<span class="variable">doc</span>));</pre><p><a class="paragraph" href="#pa052310" name="pa052310"> ¶ </a>Now, I should probably warn you that this approach is not perfect.
What it actually renders is <a name="key12"></a>XML, which is similar to HTML, but more
structured. In simple cases, such as the above, this does not cause
any problems. However, there are some things, which are correct XML,
but not proper HTML, and these might confuse a browser that is trying
to show the documents we create. For example, if you have an empty
<code>script</code> tag (used to put JavaScript into a page) in your document,
browsers will not realise that it is empty and think that everything
after it is JavaScript. (In this case, the problem can be fixed by
putting a single space inside of the tag, so that it is no longer
empty, and gets a proper closing tag.)</p></div><hr/><div class="block"><a name="exercise5"></a><div class="exercisenum">Ex. 6.5</div><div class="exercise"><p><a class="paragraph" href="#p450fc1f3" name="p450fc1f3"> ¶ </a>Write a function <code>renderFragment</code>, and use that to implement another
function <code>renderParagraph</code>, which takes a paragraph object (with the
footnotes already filtered out), and produces the correct HTML element
(which might be a paragraph or a header, depending on the <code>type</code>
property of the paragraph object).</p><p><a class="paragraph" href="#p1262e406" name="p1262e406"> ¶ </a>This function might come in useful for rendering the footnote
references:</p><pre class="code"><span class="keyword">function</span> <span class="variable">footnote</span>(<span class="variabledef">number</span>) {
  <span class="keyword">return</span> <span class="variable">tag</span>(<span class="string">&quot;sup&quot;</span>, [<span class="variable">link</span>(<span class="string">&quot;#footnote&quot;</span> + <span class="localvariable">number</span>,
                          <span class="variable">String</span>(<span class="localvariable">number</span>))]);
}</pre><p><a class="paragraph" href="#p550f2084" name="p550f2084"> ¶ </a>A <code>sup</code> tag will show its content as 'superscript', which means it
will be smaller and a little higher than other text. The target of the
link will be something like <code>&quot;#footnote1&quot;</code>. Links that contain a '#'
character refer to 'anchors' within a page, and in this case we will
use them to make it so that clicking on the footnote link will take
the reader to the bottom of the page, where the footnotes live.</p><p><a class="paragraph" href="#p371d3b74" name="p371d3b74"> ¶ </a>The tag to render emphasised fragments with is <code>em</code>, and normal text
can be rendered without any extra tags.</p></div><div class="solution"><pre class="code"><span class="keyword">function</span> <span class="variable">renderParagraph</span>(<span class="variabledef">paragraph</span>) {
  <span class="keyword">return</span> <span class="variable">tag</span>(<span class="localvariable">paragraph</span>.<span class="property">type</span>, <span class="variable">map</span>(<span class="variable">renderFragment</span>,
                                 <span class="localvariable">paragraph</span>.<span class="property">content</span>));
}

<span class="keyword">function</span> <span class="variable">renderFragment</span>(<span class="variabledef">fragment</span>) {
  <span class="keyword">if</span> (<span class="localvariable">fragment</span>.<span class="property">type</span> == <span class="string">&quot;reference&quot;</span>)
    <span class="keyword">return</span> <span class="variable">footnote</span>(<span class="localvariable">fragment</span>.<span class="property">number</span>);
  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="localvariable">fragment</span>.<span class="property">type</span> == <span class="string">&quot;emphasised&quot;</span>)
    <span class="keyword">return</span> <span class="variable">tag</span>(<span class="string">&quot;em&quot;</span>, [<span class="localvariable">fragment</span>.<span class="property">content</span>]);
  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="localvariable">fragment</span>.<span class="property">type</span> == <span class="string">&quot;normal&quot;</span>)
    <span class="keyword">return</span> <span class="localvariable">fragment</span>.<span class="property">content</span>;
}</pre></div></div><hr/><div class="block"><p><a class="paragraph" href="#p53dfa8ac" name="p53dfa8ac"> ¶ </a>We are almost finished. The only thing that we do not have a rendering
function for yet are the footnotes. To make the <code>&quot;#footnote1&quot;</code> links
work, an anchor must be included with every footnote. In HTML, an
anchor is specified with an <code>a</code> element, which is also used for links.
In this case, it needs a <code>name</code> attribute, instead of an <code>href</code>.</p><pre class="code"><span class="keyword">function</span> <span class="variable">renderFootnote</span>(<span class="variabledef">footnote</span>) {
  <span class="keyword">var</span> <span class="variabledef">number</span> = <span class="string">&quot;[&quot;</span> + <span class="localvariable">footnote</span>.<span class="property">number</span> + <span class="string">&quot;] &quot;</span>;
  <span class="keyword">var</span> <span class="variabledef">anchor</span> = <span class="variable">tag</span>(<span class="string">&quot;a&quot;</span>, [<span class="localvariable">number</span>], {<span class="property">name</span>: <span class="string">&quot;footnote&quot;</span> + <span class="localvariable">footnote</span>.<span class="property">number</span>});
  <span class="keyword">return</span> <span class="variable">tag</span>(<span class="string">&quot;p&quot;</span>, [<span class="variable">tag</span>(<span class="string">&quot;small&quot;</span>, [<span class="localvariable">anchor</span>, <span class="localvariable">footnote</span>.<span class="property">content</span>])]);
}</pre><p><a class="paragraph" href="#p2a7fb243" name="p2a7fb243"> ¶ </a>Here, then, is the function which, when given a file in the correct
format and a document title, returns an HTML document:</p><pre class="code"><span class="keyword">function</span> <span class="variable">renderFile</span>(<span class="variabledef">file</span>, <span class="variabledef">title</span>) {
  <span class="keyword">var</span> <span class="variabledef">paragraphs</span> = <span class="variable">map</span>(<span class="variable">processParagraph</span>, <span class="localvariable">file</span>.<span class="property">split</span>(<span class="string">&quot;\n\n&quot;</span>));
  <span class="keyword">var</span> <span class="variabledef">footnotes</span> = <span class="variable">map</span>(<span class="variable">renderFootnote</span>,
                      <span class="variable">extractFootnotes</span>(<span class="localvariable">paragraphs</span>));
  <span class="keyword">var</span> <span class="variabledef">body</span> = <span class="variable">map</span>(<span class="variable">renderParagraph</span>, <span class="localvariable">paragraphs</span>).<span class="property">concat</span>(<span class="localvariable">footnotes</span>);
  <span class="keyword">return</span> <span class="variable">renderHTML</span>(<span class="variable">htmlDoc</span>(<span class="localvariable">title</span>, <span class="localvariable">body</span>));
}

<span class="variable">viewHTML</span>(<span class="variable">renderFile</span>(<span class="variable">recluseFile</span>(), <span class="string">&quot;The Book of Programming&quot;</span>));</pre><p><a class="paragraph" href="#p4d390b12" name="p4d390b12"> ¶ </a>The <a name="key13"></a><code>concat</code> method of an array can be used to concatenate another
array to it, similar to what the <code>+</code> operator does with strings.</p></div><hr/><div class="block"><p><a class="paragraph" href="#p5e85639c" name="p5e85639c"> ¶ </a>In the chapters after this one, elementary higher-order functions like
<code>map</code> and <code>reduce</code> will always be available and will be used by code
examples. Now and then, a new useful tool is added to this. In
<a href="chapter9.html">chapter 9</a>, we develop a more structured approach to this set of
'basic' functions.</p></div><hr/><div class="block"><p><a class="paragraph" href="#p2a12fc11" name="p2a12fc11"> ¶ </a>When using higher-order functions, it is often annoying that operators
are not functions in JavaScript. We have needed <code>add</code> or <code>equals</code>
functions at several points. Rewriting these every time, you will
agree, is a pain. From now on, we will assume the existence of an
object called <code>op</code>, which contains these functions:</p><pre class="code"><span class="keyword">var</span> <span class="variable">op</span> = {
  <span class="string">&quot;+&quot;</span>: <span class="keyword">function</span>(<span class="variabledef">a</span>, <span class="variabledef">b</span>){<span class="keyword">return</span> <span class="localvariable">a</span> + <span class="localvariable">b</span>;},
  <span class="string">&quot;==&quot;</span>: <span class="keyword">function</span>(<span class="variabledef">a</span>, <span class="variabledef">b</span>){<span class="keyword">return</span> <span class="localvariable">a</span> == <span class="localvariable">b</span>;},
  <span class="string">&quot;===&quot;</span>: <span class="keyword">function</span>(<span class="variabledef">a</span>, <span class="variabledef">b</span>){<span class="keyword">return</span> <span class="localvariable">a</span> === <span class="localvariable">b</span>;},
  <span class="string">&quot;!&quot;</span>: <span class="keyword">function</span>(<span class="variabledef">a</span>){<span class="keyword">return</span> !<span class="localvariable">a</span>;}
  <span class="comment">/* and so on */</span>
};</pre><p><a class="paragraph" href="#p6f6235e5" name="p6f6235e5"> ¶ </a>So we can write <code>reduce(op[&quot;+&quot;], 0, [1, 2, 3, 4, 5])</code> to sum an array.
But what if we need something like <code>equals</code> or <code>makeAddFunction</code>, in
which one of the arguments already has a value? In that case we are
back to writing a new function again.</p><p><a class="paragraph" href="#p5d659723" name="p5d659723"> ¶ </a>For cases like that, something called '<a name="key14"></a>partial application' is
useful. You want to create a new function that already knows some of
its arguments, and treats any additional arguments it is passed as
coming after these fixed arguments. This can be done by making
creative use of the <code>apply</code> method of a function:</p><pre class="code"><span class="keyword">function</span> <span class="variable">asArray</span>(<span class="variabledef">quasiArray</span>, <span class="variabledef">start</span>) {
  <span class="keyword">var</span> <span class="variabledef">result</span> = [];
  <span class="keyword">for</span> (<span class="keyword">var</span> <span class="variabledef">i</span> = (<span class="localvariable">start</span> || <span class="atom">0</span>); <span class="localvariable">i</span> &lt; <span class="localvariable">quasiArray</span>.<span class="property">length</span>; <span class="localvariable">i</span>++)
    <span class="localvariable">result</span>.<span class="property">push</span>(<span class="localvariable">quasiArray</span>[<span class="localvariable">i</span>]);
  <span class="keyword">return</span> <span class="localvariable">result</span>;
}

<span class="keyword">function</span> <span class="variable">partial</span>(<span class="variabledef">func</span>) {
  <span class="keyword">var</span> <span class="variabledef">fixedArgs</span> = <span class="variable">asArray</span>(<span class="localvariable">arguments</span>, <span class="atom">1</span>);
  <span class="keyword">return</span> <span class="keyword">function</span>(){
    <span class="keyword">return</span> <span class="localvariable">func</span>.<span class="property">apply</span>(<span class="atom">null</span>, <span class="localvariable">fixedArgs</span>.<span class="property">concat</span>(<span class="variable">asArray</span>(<span class="localvariable">arguments</span>)));
  };
}</pre><p><a class="paragraph" href="#p60ca0eee" name="p60ca0eee"> ¶ </a>We want to allow binding multiple arguments at the same time, so the
<code>asArray</code> function is necessary to make normal arrays out of the
<code>arguments</code> objects. It copies their content into a real array, so
that the <code>concat</code> method can be used on it. It also takes an optional
second argument, which can be used to leave out some arguments at the
start.</p><p><a class="paragraph" href="#p255ffd22" name="p255ffd22"> ¶ </a>Also note that it is necessary to store the <code>arguments</code> of the outer
function (<code>partial</code>) into a variable with another name, because
otherwise the inner function can not see them ― it has its own
<code>arguments</code> variable, which shadows the one of the outer function.</p><p><a class="paragraph" href="#p68397052" name="p68397052"> ¶ </a>Now <code>equals(10)</code> could be written as <code>partial(op[&quot;==&quot;], 10)</code>, without
the need for a specialized <code>equals</code> function. And you can do things
like this:</p><pre class="code"><span class="variable">show</span>(<span class="variable">map</span>(<span class="variable">partial</span>(<span class="variable">op</span>[<span class="string">&quot;+&quot;</span>], <span class="atom">1</span>), [<span class="atom">0</span>, <span class="atom">2</span>, <span class="atom">4</span>, <span class="atom">6</span>, <span class="atom">8</span>, <span class="atom">10</span>]));</pre><p><a class="paragraph" href="#p662c705c" name="p662c705c"> ¶ </a>The reason <code>map</code> takes its function argument before its array argument
is that it is often useful to partially apply map by giving it a
function. This 'lifts' the function from operating on a single value
to operating on an array of values. For example, if you have an array
of arrays of numbers, and you want to square them all, you do this:</p><pre class="code"><span class="keyword">function</span> <span class="variable">square</span>(<span class="variabledef">x</span>) {<span class="keyword">return</span> <span class="localvariable">x</span> * <span class="localvariable">x</span>;}

<span class="variable">show</span>(<span class="variable">map</span>(<span class="variable">partial</span>(<span class="variable">map</span>, <span class="variable">square</span>), [[<span class="atom">10</span>, <span class="atom">100</span>], [<span class="atom">12</span>, <span class="atom">16</span>], [<span class="atom">0</span>, <span class="atom">1</span>]]));</pre></div><hr/><div class="block"><p><a class="paragraph" href="#p1b0a11ff" name="p1b0a11ff"> ¶ </a>One last trick that can be useful when you want to combine functions
is <a name="key15"></a>function composition. At the start of this chapter I showed a
function <code>negate</code>, which applies the boolean <em>not</em> operator to the
result of calling a function:</p><pre class="code"><span class="keyword">function</span> <span class="variable">negate</span>(<span class="variabledef">func</span>) {
  <span class="keyword">return</span> <span class="keyword">function</span>() {
    <span class="keyword">return</span> !<span class="localvariable">func</span>.<span class="property">apply</span>(<span class="atom">null</span>, <span class="localvariable">arguments</span>);
  };
}</pre><p><a class="paragraph" href="#p7069c39a" name="p7069c39a"> ¶ </a>This is a special case of a general pattern: call function A, and then
apply function B to the result. Composition is a common concept in
mathematics. <a name="key16"></a>It can be caught in a higher-order function
like this:</p><pre class="code"><span class="keyword">function</span> <span class="variable">compose</span>(<span class="variabledef">func1</span>, <span class="variabledef">func2</span>) {
  <span class="keyword">return</span> <span class="keyword">function</span>() {
    <span class="keyword">return</span> <span class="localvariable">func1</span>(<span class="localvariable">func2</span>.<span class="property">apply</span>(<span class="atom">null</span>, <span class="localvariable">arguments</span>));
  };
}

<span class="keyword">var</span> <span class="variable">isUndefined</span> = <span class="variable">partial</span>(<span class="variable">op</span>[<span class="string">&quot;===&quot;</span>], <span class="atom">undefined</span>);
<span class="keyword">var</span> <span class="variable">isDefined</span> = <span class="variable">compose</span>(<span class="variable">op</span>[<span class="string">&quot;!&quot;</span>], <span class="variable">isUndefined</span>);
<span class="variable">show</span>(<span class="variable">isDefined</span>(<span class="variable">Math</span>.<span class="property">PI</span>));
<span class="variable">show</span>(<span class="variable">isDefined</span>(<span class="variable">Math</span>.<span class="property">PIE</span>));</pre><p><a class="paragraph" href="#p5221ce46" name="p5221ce46"> ¶ </a>Here we are defining new functions without using the <code>function</code>
keyword at all. This can be useful when you need to create a simple
function to give to, for example, <code>map</code> or <code>reduce</code>. However, when a
function becomes more complex than these examples, it is usually
shorter (not to mention more efficient) to just write it out with
<code>function</code>.</p></div><ol class="footnotes"><li><a name="footnote1"></a>Like this...</li></ol><div class="navigation"><a href="chapter5.html">&lt;&lt; Previous chapter</a> | <a href="contents.html">Contents</a> | <a href="index.html">Cover</a> | <a href="chapter7.html">Next chapter &gt;&gt;</a></div><div class="footer">© <a href="mailto:marijnh@gmail.com">Marijn Haverbeke</a> (<a href="http://creativecommons.org/licenses/by/3.0/">license</a>), written March to July 2007, last modified on March 22 2013.</div></div><script type="text/javascript" src="js/mochi.js"> </script><script type="text/javascript" src="js/codemirror.js"> </script><script type="text/javascript" src="js/ejs.js"> </script></body></html>